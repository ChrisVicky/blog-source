---
title: 数据结构期末复习
categories:
  - Post
date: 2023-06-11 19:03:40
tags:
    - 数据结构
    - 期末复习
    - 笔记
cover: /myimg/data-structure-mind-map.png
---

<center>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="100%"
        src="/img/image_2023-06-11-19-44-33.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">MindMap</div>
</center>

* 2023-06-16 考试复习版

## 复习重点

### 绪论
* [x] [基本概念和术语](#基本概念和术语)
* [x] [时间复杂度计算](#时间复杂度计算)

### 线性表
* [x] [线性表](#线性表)、[顺序表](#顺序表)、[单链表](#单链表)的基本操作和算法
* [x] [循环链表](#循环链表)、[双向循环链表操作](#双向循环链表操作)


### 栈和队列
* [ ] 栈的定义、特点、基本操作和算法
* [ ] 队列的定义、特点、基本操作和算法
* [ ] 递归

### 数据和广义表
* [ ] 上三角矩阵、下三角矩阵、稀疏矩阵存储与表示

### 树和二叉树
* [ ] 二叉树定义、性质
* [ ] 二叉树构造
* [ ] 二叉树遍历和算法（递归/非递归）
* [ ] 二叉树应用: 技术
* [ ] 树/森林 和 二叉树转换
* [ ] 哈夫曼树的构建
    * [ ] 哈夫曼编码，求加权路径长度

### 图
* [ ] 图的定义、存储结构
* [ ] 图的遍历（广搜，深搜）
* [ ] Prim 构建最小生成树
* [ ] 拓扑排序实现过程
* [ ] 关键路径实现
    * [ ] 给出各事件最早、最晚开始时间，路径上各活动最早、最晚开始时间
* [ ] 最短路径实现过程

### 查找
* [ ] 顺序表查找、折半查找
* [ ] 二叉排序树查找、插入、删除过程
* [ ] 构造平衡二叉树
* [ ] B- 树构建、实现
* [ ] 基于哈希函数构建哈希表（散列表）
    * [ ] 除留余数法解决冲突
    * [ ] 线性深测处理
    * [ ] 二次深测处理

### 内排序
* [ ] 直接插入、折半插入、希尔排序
* [ ] 冒泡、快速排序
* [ ] 直接选择、堆排序
* [ ] 归并排序

---

## 复习笔记

### 绪论

#### 基本概念和术语
<center>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
        width="80%" src="/img/image_2023-06-11-15-39-34.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">基本概念和术语</div>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
        width="80%" src="/img/image_2023-06-11-16-06-36.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">存储结构</div>
</center>

#### 时间复杂度计算
<center>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="80%"
        src="/img/image_2023-06-11-15-50-00.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">时间复杂度</div>
</center>

* 几个需要记住的时间复杂度表示

$$
n\ge16 
O(1) < O(log_2N) < O(N) < O(Nlog_2N) < O(N^2) < O(N^3) < O(2^N)
$$

> $O(Nlog_2N)$ : 线性对数时间

![image_2023-06-11-15-55-41](/img/image_2023-06-11-15-55-41.png)

<center>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="80%"
        src="/img/image_2023-06-11-15-58-14.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">插入排序计算时间复杂度例子</div>
</center>

> Takeaway: 计算时间复杂度时在程序边上写出赋值之类的操作，并写出完整的公式，虽然最后可以用 $O$ 符号来规约，但我猜这个完整的式子是有分的。

---

### 线性表
* 线性表：除第一个以外都有且仅有一个前驱（同理后继）

#### 顺序表：
* 是线性表的顺序存储方式，元素在连续的存储空间中，数组存储

##### 基本操作
* 搜索平均比较次数：$ACN = \frac{1}{n}\sum\limits_{i=0}^{n-1}(i+1) = \frac{1+n}{2} = O(n)$
    > 有 $n$ 个数需要比较，第 $i$ 个正确时比较了 $i+1$ 次
    > > 这里其实有`BUG`，即这里的平均是：匹配成功的平均比较次数，但是显然匹配失败的比较次数大概率时 $n$ 次

* 插入平均数据移动次数：$AMN=\frac{1}{n+1}\sum\limits_{i=0}^{n}(n-i)=\frac{n}{2}=O(n)$
    > 有 $n+1$ 个位置插入，每次插入第 $i$ 个位置时会移动 $n-i$ 个

* 删除平均数据移动次数：$AMN=\frac{1}{n}\sum\limits_{i=0}^{n-1}(n-i-1)=\frac{n-1}{2}=O(n)$
    > 有 $n$ 个数可以删除，删除第 $i$ 个时需要移动 $(n-i-1)$ 个数

##### 算法：
* 有序向量去重 (快慢指针) 
    ```go
    // uniquify 
    // Before: [1 1 1 1 3 4 4 5 5 6]
    // After:  [1 3 4 5 6]
    func uniquify(arr[] int) (length int){
        fmt.Println("Before:", arr)
        length = len(arr)
        i, j := 0, 0
        for ; j<length;j++{
            if arr[i] != arr[j] {
                i++
                arr[i] = arr[j]
            }
        }
        length = i+1
        fmt.Println("After: ", arr[:length])
        return 
    }
    ```
* 有序向量查找（二分法）
    ```go
    // binary_search 
    // Array:  [1 2 4 6 7] find 7
    // Found:  [        ^] found: idx = 4
    func binary_search(arr[] int, x int)(mid int){
        // [l, r)
        l, r := 0, len(arr)
        for; l<r;{
            mid = ((l+r) >> 1)
            if arr[mid] < x {
                l = mid+1
            }else if arr[mid] > x{
                r = mid
            }else{
                return
            }
        }
        mid = -1
        return
    }
    ```

##### 优缺点
* 优点：简单、运算方便，短小、固定长度的线性表有优越性，随机访问效率高。
* 缺点：顺序存储、插入删除元素需要移动，效率低。预分配空间不灵活。

#### 链表
* `数据域 + 指针域`
* 存储单元可以不连续
* 顺序存取
* `带头结点的表`：即有一个没有`数据域`的指针作为头，可以简化链表操作的实现

##### 基本操作
* 插入
    * 首个结点之前插入（若有专门的`头结点`则与中间插入相同）
    ```cpp
    newnode->link = first;
    first = newnode;
    ```
    * 链表中间插入
    ```cpp
    newnode->link = p->link;
    p->link = newnode;
    ```
    > `p` 是被插入结点的前一个
    * 链表末尾：单链表同中间插入（只是这个 `p->link` 本身就是 `NULL`）

* 删除
    ```cpp
    q = p->link;
    p->link = q->link;
    ```
<center>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="80%"
        src="/img/image_2023-06-11-18-31-13.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">Takeaway</div>
</center>


##### 算法

<center>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="80%"
        src="/img/image_2023-06-11-18-34-56.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">随堂练习</div>
</center>

>答案：`(c)(f)(b)(e)(a)(d)`

##### 静态链表
* 使用数组模拟链表，指针域从原先的`指向某个地址（虚拟地址）` `变为` `指向某个地址（在数组中的编号）`

#### 循环链表
* 最后一个结点的 `link` 指向 `头结点`

<center>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="80%"
        src="/img/image_2023-06-11-18-39-23.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">空表</div>
</center>

#### 双向链表
* 循环链表再加一个反向的指针

<center>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="80%"
        src="/img/image_2023-06-11-18-46-21.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">双向链表</div>
</center>

### 顺序表 $VS$ 链表
<center>
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="45%"
        src="/img/image_2023-06-11-18-48-39.png">
    <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" width="50%"
        src="/img/image_2023-06-11-18-48-52.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">顺序表 vs 链表</div>
</center>

---

